<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Player Rankings</title>
    <!-- CSV parser for browser (UMD) -->
    <script src="https://cdn.jsdelivr.net/npm/d3-dsv@3"></script>
    <style>
        .TopButtons{
            display: flex;
            margin-left: 100px;
            gap: 20px;
            margin-top: 20px;
        }
        .HomeButton{
            background-color: #06a2aa;
            color: #ffffff;
            width: 100px;
            height: 30px;
            border-radius: 20px;
        }
        .HomeBtn{
            text-decoration: none;
        }
        .HomeButton:hover{
            cursor: pointer;
        }
        .PlayerComparisonsButton{
            position: absolute;
            background-color: #06a2aa;
            color: #ffffff;
            width: 200px;
            height: 30px;
            border-radius: 20px;
        }
        .PlayerComparisonsBtn{
            text-decoration: none;
        }
        .PlayerComparisonsButton:hover{
            cursor: pointer;
        }
        body{
            background-image: linear-gradient(to right, #000000, #1a0527);

        }
        h1{
            margin-left: 100px;
            margin-top: 20px;
            display: inline-flex;
            font-family: 'Poppins', sans-serif;
            font-size: 27px;
            justify-content: center;
            align-items: center; 
            background-color: #c4ff21; 
            width: 600px;
            height: 150px;
            border-radius: 8px;
            color: black;
            font-weight: 549;

        }
        .buttons{
            margin-left: 100px;
            display: flex;
            align-items: center;
        }
        .dropbtn{
            background-color: #06a2aa;
            color: #ffffff;
            width: 100px;
            height: 50px;
            border-radius: 20px;
            cursor: pointer;

        }
        .dropdown_content {  
            display: none;
            position: absolute;
            background-color: #06a2aa;
            color: #ffffff;
            min-width: 120px;
            box-shadow: 0px 8px 16px rgba(0,0,0,0.2);
            border-radius: 5px;
            max-height: 200px; /* scroll if too many years */
            overflow-y: auto;
            z-index: 1;
    }

    /* Dropdown items */
    .dropdown_content div {
        padding: 10px;
        cursor: pointer;
    }

    /* Hover effect for items */
    .dropdown_content div:hover {
        background-color: #0d8cc7;
    }

    .NationsSearch{
        position: relative;
        display: inline-block;
        margin-left: 20px;
    }

    .countrySearchBar{
        background-color: #06a2aa;
        color: #ffffff;
        height: 28px;
        text-align: center;
    }
    .countrySearchBar::placeholder{
        color: #ffffff;
    }
    .CountrySuggestionsDropdown{
        display: none;
        position: absolute;
        background-color: #06a2aa;
        color: #ffffff;
        min-width: 120px;
        box-shadow: 0px 8px 16px rgba(0,0,0,0.2);
        border-radius: 5px;
        max-height: 200px; /* scroll if too many years */
        overflow-y: auto;
        z-index: 1;
    }
    .CountrySuggestionsDropdown div {
        padding: 10px;
        cursor: pointer;
    }
    .CountrySuggestionsDropdown div:hover {
        background-color: #0d8cc7;
    }


    .PlayerSearch{
        position: relative;
        display: inline-block;
        margin-left: 20px;
    }

    .PlayerSearchBar{
        background-color: #06a2aa;
        color: #ffffff;
        height: 28px;
        text-align: center;
    }
    .PlayerSearchBar::placeholder{
        color: #ffffff;
    }
    .PlayerSuggestionsDropdown{
        display: none;
        position: absolute;
        background-color: #06a2aa;
        color: #ffffff;
        min-width: 120px;
        box-shadow: 0px 8px 16px rgba(0,0,0,0.2);
        border-radius: 5px;
        max-height: 200px; /* scroll if too many years */
        overflow-y: auto;
        z-index: 1;
    }
    .PlayerSuggestionsDropdown div {
        padding: 10px;
        cursor: pointer;
    }
    .PlayerSuggestionsDropdown div:hover {
        background-color: #0d8cc7;
    }

    .resetButton{
        margin-left: 20px;
        background-color: #06a2aa;
        color: #ffffff;
        width: 100px;
        height: 50px;
        border-radius: 20px;
    }
    .resetButton:hover{
        cursor: pointer;
    }

    table { 
        border-collapse: collapse;
        width: 100%; 
        margin-top: 16px; 
    }
    th, td { 
        border: 1px transparent; 
        padding: 16px; text-align:left; 
    }
    th { 
        background: transparent;
        color: #c4ff21;
        font-size: 27px;
    }
    tbody { 
        background: transparent;
        color: #ffffff;
        font-size: 20px;
    }
    .LoadMoreBtn{
        background-color: #06a2aa;
        color: #ffffff;
        width: 150px;
        height: 50px;
        align-self: center;
        border-radius: 30px;
        display: block;
        margin: 20px auto;
    }
    </style>
</head>
<body>
    <DIV class="TopButtons">
        <a href="Homepage.html" class="HomeBtn">
        <button class="HomeButton">HOME</button>
        </a>
        <a href="PlayerComparisons.html" class="PlayerComparisonsBtn">
        <button class="PlayerComparisonsButton">PLAYER COMPARISONS</button>
    </a>
    </DIV>

    <h1>
        GRAND SLAM PLAYER RANKINGS
    </h1>

    <div class="buttons">
        <button class="dropbtn" id="dropdownBtn">2025</button>
        <div class="dropdown_content" id="dropdownMenu">
         <!-- Years will be inserted here by JavaScript -->
        </div>
        <div class = NationsSearch>
            <input 
                class = "countrySearchBar"
                type="text" 
                id="countrySearch" 
                placeholder="Search by country" 
                style="padding: 8px 12px; border-radius: 8px; border: none; width: 180px;"
                autocomplete="off">
                <div class="CountrySuggestionsDropdown" id="countrySuggestions"></div>
        </div>
        <div class = PlayerSearch>
            <input 
                class = "PlayerSearchBar"
                type="text" 
                id="playerSearch" 
                placeholder="Search for a player" 
                style="padding: 8px 12px; border-radius: 8px; border: none; width: 180px;"
                autocomplete="off">
                <div class="PlayerSuggestionsDropdown" id="playerSuggestions"></div>
        </div>
        <button class="resetButton" id="Reset">RESET</button>
    </div>

    <table id="rankingTable">
    <thead>
      <tr>
        <th>Rank</th>
        <th>Player</th>
        <th>ELO</th>
      </tr>
    </thead>
    <tbody>
      <!-- Rankings will appear here -->
    </tbody>
  </table>
  <button class = "LoadMoreBtn" id="LoadMoreButton">
    Load More
  </button>

  <script>
    // --- Utilities (ported from src/App.tsx, simplified to JS) ---
    function parseDateFlexible(raw) {
      if (raw == null) return null;
      const s = String(raw).trim();
      if (!s) return null;
      if (/^\d{8}$/.test(s)) {
        const y = +s.slice(0, 4);
        const m = +s.slice(4, 6);
        const d = +s.slice(6, 8);
        const dt = new Date(Date.UTC(y, m - 1, d));
        return isNaN(+dt) ? null : dt;
      }
      if (/^\d{4}[-\/]\d{2}[-\/]\d{2}/.test(s)) {
        const dt = new Date(s.replace(/\//g, "-"));
        return isNaN(+dt) ? null : dt;
      }
      const m1 = s.match(/^(\d{1,2})[./-](\d{1,2})[./-](\d{2,4})$/);
      if (m1) {
        const d = +m1[1], m = +m1[2], y = +m1[3] < 100 ? 2000 + +m1[3] : +m1[3];
        const dt = new Date(Date.UTC(y, m - 1, d));
        return isNaN(+dt) ? null : dt;
      }
      const dt = new Date(s);
      return isNaN(+dt) ? null : dt;
    }

    function expectedScore(Ra, Rb, s) {
      const scale = s || 400;
      return 1 / (1 + Math.pow(10, (Rb - Ra) / scale));
    }
    function updateElo(Ra, Rb, scoreA, K) {
      const Ea = expectedScore(Ra, Rb);
      const Eb = 1 - Ea;
      const newA = Ra + (K || 32) * (scoreA - Ea);
      const newB = Rb + (K || 32) * ((1 - scoreA) - Eb);
      return [newA, newB];
    }
    const dropdownBtn = document.getElementById('dropdownBtn');
    const dropdownMenu = document.getElementById('dropdownMenu');
    const LoadMoreBtn = document.getElementById('LoadMoreButton');
    // keep variable name consistent in handlers below
    const countrySearch = document.getElementById('countrySearch');
    const countrySuggestions = document.getElementById("countrySuggestions");
    const PlayerSearch = document.getElementById('playerSearch')
    const playerSuggestions = document.getElementById('playerSuggestions')
    const ResetButton = document.getElementById("Reset")
    // computed rankings cache (built once from CSVs)
    let GLOBAL_RANKINGS = [];
    let countries = {};
    let selectedPlayer = null;
    let selectedCountryCode = null;
    let SelectedYear = 2025 
    let CurrentLoaded = 10

    // Generate years 2000 to 2025
    for (let year = 2025; year >= 2000; year--) {
        const item = document.createElement('div');
        item.textContent = year;
        item.addEventListener('click', () => {
        dropdownBtn.textContent = year; // Set button text to selected year
        SelectedYear = year
        CurrentLoaded = 10
        displayRankings(SelectedYear, CurrentLoaded, selectedCountryCode);
        dropdownMenu.style.display = 'none'; // Close dropdown
        });
        dropdownMenu.appendChild(item);
    }

    // Toggle dropdown on button click
    dropdownBtn.addEventListener('click', () => {
        dropdownMenu.style.display = dropdownMenu.style.display === 'block' ? 'none' : 'block';
    });

    // Close dropdown if clicked outside
    window.addEventListener('click', (e) => {
        if (!e.target.matches('.dropbtn')) {
        dropdownMenu.style.display = 'none';
        }
    });

    LoadMoreBtn.addEventListener('click', () => {
        CurrentLoaded += 10
        displayRankings(SelectedYear, CurrentLoaded, selectedCountryCode)
    })

    countrySearch.addEventListener("input", () => {
        const query = countrySearch.value.toUpperCase();
        countrySuggestions.innerHTML = "";
        if (!query) {
            countrySuggestions.style.display = "none";
            selectedCountryCode = null;
            displayRankings(SelectedYear, CurrentLoaded, selectedCountryCode);
            return;
        }

        const matches = Object.entries(countries)
            .filter(([code, name]) => name.includes(query))
            .slice(0, 10); // max 10 suggestions

        matches.forEach(([code, name]) => {
            const div = document.createElement("div");
            div.textContent = name;
            div.addEventListener("click", () => {
            countrySearch.value = name;
            selectedCountryCode = code;
            countrySuggestions.style.display = "none";
            CurrentLoaded = 10;
            displayRankings(SelectedYear, CurrentLoaded, selectedCountryCode);
            });
            countrySuggestions.appendChild(div);
        });

        countrySuggestions.style.display = matches.length ? "block" : "none";
        });

    countrySearch.addEventListener("focus", () => {
        countrySearch.value = "";              
        countrySuggestions.style.display = "none";
    });

    ResetButton.addEventListener('click', () => {
        CurrentLoaded = 10
        selectedCountryCode = null
        SelectedYear = 2025
        displayRankings(SelectedYear, CurrentLoaded)
        dropdownBtn.textContent = "2025";
        countrySearch.value = "";
    })

    window.addEventListener("click", (e) => {
        if (e.target !== countrySearch) {
            countrySuggestions.style.display = "none";
        }
        });


    fetch("public/CountryCodes.json")
        .then(res => res.json())
        .then(data => {countries = data;})
        .catch(err => console.error("Failed to load countries.json", err));
    // Build rankings once from CSVs, then render
    async function buildRankingsFromCsv() {
      try {
        const [playersText, matchesText] = await Promise.all([
          fetch("public/players.csv").then(r => r.text()),
          fetch("public/matches.csv").then(r => r.text()),
        ]);

        // Use d3-dsv for robust CSV parsing
        const playersRows = (window.d3 && d3.csvParse) ? d3.csvParse(playersText) : [];
        const matchesRows = (window.d3 && d3.csvParse) ? d3.csvParse(matchesText) : [];

        // Build player maps
        const playersById = new Map();
        const idToCountry = new Map();
        const idToName = new Map();
        const nameIndex = new Map(); // lowercased name -> id
        const normIndex = new Map(); // lowercased name_norm -> id

        const pNameKey = (playersRows.columns || []).find(c => c.toLowerCase() === 'name') || 'name';
        const pNormKey = (playersRows.columns || []).find(c => /norm/i.test(c)) || 'name_norm';
        const pIdKey = (playersRows.columns || []).find(c => /(^|_)id$/i.test(c)) || 'player_id';
        const pIocKey = (playersRows.columns || []).find(c => /ioc|country/i.test(c)) || 'ioc';

        playersRows.forEach(r => {
          const id = String(r[pIdKey] || '').trim();
          const nm = String(r[pNameKey] || '').trim();
          const nn = String(r[pNormKey] || '').trim();
          const ioc = String(r[pIocKey] || 'UNK').trim();
          if (!id || !nm) return;
          playersById.set(id, { id, name: nm, norm: nn, country: ioc });
          idToCountry.set(id, ioc);
          idToName.set(id, nm);
          nameIndex.set(nm.toLowerCase(), id);
          if (nn) normIndex.set(nn.toLowerCase(), id);
        });

        // Prepare matches array with correct IDs
        const mCols = matchesRows.columns || [];
        const dateKey = mCols.find(c => /date|tourney_date|match_date/i.test(c)) || mCols[0];
        const wPidKey = mCols.find(c => /winner.*player.*id/i.test(c)) || mCols.find(c => /^winner_?id$/i) || 'winner_id';
        const lPidKey = mCols.find(c => /loser.*player.*id/i.test(c))  || mCols.find(c => /^loser_?id$/i)  || 'loser_id';
        const wNameKey = mCols.find(c => /winner.*name|^winner$/i) || 'winner_name';
        const lNameKey = mCols.find(c => /loser.*name|^loser$/i)  || 'loser_name';
        const wIocKey = mCols.find(c => /winner.*ioc/i.test(c)) || 'winner_ioc';
        const lIocKey = mCols.find(c => /loser.*ioc/i.test(c)) || 'loser_ioc';
        const keyKey  = mCols.find(c => /match_key/i.test(c)) || 'match_key';

        // helper to resolve mislabelled 2025 De Minaur cases using match_key/ioc hints
        let deMinaurId = null;
        for (const [id, p] of playersById.entries()) {
          if ((p.name && p.name.toLowerCase() === 'alex de minaur') || (p.norm && p.norm.toLowerCase() === 'alex de minaur')) {
            deMinaurId = id; break;
          }
        }

        const matches = [];
        for (const r of matchesRows) {
          const dt = parseDateFlexible(r[dateKey]);
          if (!dt) continue;
          let w = String(r[wPidKey] || '').trim();
          let l = String(r[lPidKey] || '').trim();
          const mk = String(r[keyKey] || '');
          const mkMatch = mk.match(/(.+)_vs_(.+)$/);
          const mkW = mkMatch ? mkMatch[1].replace(/_/g,' ').replace(/\.+$/,'').trim().toLowerCase() : '';
          const mkL = mkMatch ? mkMatch[2].replace(/_/g,' ').replace(/\.+$/,'').trim().toLowerCase() : '';
          if (!w) {
            const wn = String(r[wNameKey] || '').trim().toLowerCase();
            if (wn && (nameIndex.has(wn) || normIndex.has(wn))) {
              w = nameIndex.get(wn) || normIndex.get(wn) || '';
            } else if (deMinaurId && (wn.includes('de minaur') || mkW.includes('de minaur')) && String(r[wIocKey]||'') === 'AUS') {
              w = deMinaurId;
            }
          }
          if (!l) {
            const ln = String(r[lNameKey] || '').trim().toLowerCase();
            if (ln && (nameIndex.has(ln) || normIndex.has(ln))) {
              l = nameIndex.get(ln) || normIndex.get(ln) || '';
            } else if (deMinaurId && (ln.includes('de minaur') || mkL.includes('de minaur')) && String(r[lIocKey]||'') === 'AUS') {
              l = deMinaurId;
            }
          }
          // If IDs exist but ioc mismatches and match_key suggests De Minaur, correct them
          if (deMinaurId && String(r[wIocKey]||'') === 'AUS') {
            const wn = String(r[wNameKey] || '').toLowerCase();
            const idCountry = idToCountry.get(w) || '';
            if ((!w || idCountry !== 'AUS') && (wn.includes('de minaur') || mkW.includes('de minaur'))) w = deMinaurId;
          }
          if (deMinaurId && String(r[lIocKey]||'') === 'AUS') {
            const ln = String(r[lNameKey] || '').toLowerCase();
            const idCountry = idToCountry.get(l) || '';
            if ((!l || idCountry !== 'AUS') && (ln.includes('de minaur') || mkL.includes('de minaur'))) l = deMinaurId;
          }
          if (!w || !l) continue;
          matches.push({ date: dt.toISOString(), winner_id: w, loser_id: l });
        }

        // Compute Elo and collect last rating per player per year
        const base = 1500;
        const K = 32;
        const elo = new Map();
        const lastEloPerYear = new Map(); // year -> Map(playerId -> {player_id,name,country,elo})

        matches.sort((a,b) => new Date(a.date) - new Date(b.date));
        for (const m of matches) {
          const Ra = elo.get(m.winner_id) ?? base;
          const Rb = elo.get(m.loser_id) ?? base;
          const [newW, newL] = updateElo(Ra, Rb, 1, K);
          elo.set(m.winner_id, newW);
          elo.set(m.loser_id, newL);

          const y = new Date(m.date).getFullYear().toString();
          if (!lastEloPerYear.has(y)) lastEloPerYear.set(y, new Map());
          const ym = lastEloPerYear.get(y);
          const wName = idToName.get(m.winner_id) || m.winner_id;
          const lName = idToName.get(m.loser_id)  || m.loser_id;
          const wC = idToCountry.get(m.winner_id) || 'UNK';
          const lC = idToCountry.get(m.loser_id)  || 'UNK';
          ym.set(m.winner_id, { player_id: m.winner_id, name: wName, country: wC, elo: newW });
          ym.set(m.loser_id,  { player_id: m.loser_id,  name: lName, country: lC, elo: newL });
        }

        const result = [];
        for (const [year, map] of lastEloPerYear.entries()) {
          for (const v of map.values()) result.push({ year: +year, ...v });
        }
        GLOBAL_RANKINGS = result;
        // initial render
        displayRankings(SelectedYear, CurrentLoaded, selectedCountryCode);
      } catch (e) {
        console.error('Failed to build rankings from CSV:', e);
      }
    }

    function displayRankings(year, CurrentLoaded, selectedCountryCode = null) {
      const tbody = document.querySelector('#rankingTable tbody');
      tbody.innerHTML = '';
      let filtered = (GLOBAL_RANKINGS || []).filter(d => d.year === year)
        .sort((a,b) => b.elo - a.elo);
      if (selectedCountryCode) {
        filtered = filtered.filter(d => d.country === selectedCountryCode);
      }
      filtered = filtered.slice(0, CurrentLoaded);
      filtered.forEach((player, index) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${index + 1}</td>
          <td>${player.name}</td>
          <td>${Math.ceil(player.elo)}</td>
        `;
        tbody.appendChild(tr);
      });
    }

    // Kick off data load immediately
    buildRankingsFromCsv();
  </script>
</body>
</html>

